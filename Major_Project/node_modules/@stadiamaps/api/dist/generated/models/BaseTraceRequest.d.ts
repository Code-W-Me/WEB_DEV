import { CostingOptions } from './CostingOptions';
import { MapMatchCostingModel } from './MapMatchCostingModel';
import { DistanceUnit } from './DistanceUnit';
import { RoutingLanguages } from './RoutingLanguages';
import { MapMatchWaypoint } from './MapMatchWaypoint';
/**
 *
 * @export
 * @interface BaseTraceRequest
 */
export interface BaseTraceRequest {
    /**
     *
     * @type {DistanceUnit}
     * @memberof BaseTraceRequest
     */
    units?: DistanceUnit;
    /**
     *
     * @type {RoutingLanguages}
     * @memberof BaseTraceRequest
     */
    language?: RoutingLanguages;
    /**
     * The level of directional narrative to include. Locations and times will always be returned, but narrative generation verbosity can be controlled with this parameter.
     * @type {string}
     * @memberof BaseTraceRequest
     */
    directionsType?: BaseTraceRequestDirectionsTypeEnum;
    /**
     * An identifier to disambiguate requests (echoed by the server).
     * @type {string}
     * @memberof BaseTraceRequest
     */
    id?: string;
    /**
     * REQUIRED if `encoded_polyline` is not present. Note that `break` type locations are only supported when `shape_match` is set to `map_match`.
     * @type {Array<MapMatchWaypoint>}
     * @memberof BaseTraceRequest
     */
    shape?: Array<MapMatchWaypoint>;
    /**
     * REQUIRED if `shape` is not present. An encoded polyline (https://developers.google.com/maps/documentation/utilities/polylinealgorithm). Note that the polyline must be encoded with 6 digits of precision rather than the default 5!
     * @type {string}
     * @memberof BaseTraceRequest
     */
    encodedPolyline?: string;
    /**
     *
     * @type {MapMatchCostingModel}
     * @memberof BaseTraceRequest
     */
    costing: MapMatchCostingModel;
    /**
     *
     * @type {CostingOptions}
     * @memberof BaseTraceRequest
     */
    costingOptions?: CostingOptions;
    /**
     * Three snapping modes provide some control over how the map matching occurs. `edge_walk` is fast, but requires extremely precise data that matches the route graph almost perfectly. `map_snap` can handle significantly noisier data, but is very expensive. `walk_or_snap`, the default, tries to use edge walking first and falls back to map matching if edge walking fails.
     * In general, you should not need to change this parameter unless you want to trace a multi-leg route with multiple `break` locations in the `shape`.
     * @type {string}
     * @memberof BaseTraceRequest
     */
    shapeMatch?: BaseTraceRequestShapeMatchEnum;
}
/**
 * @export
 */
export declare const BaseTraceRequestDirectionsTypeEnum: {
    readonly None: "none";
    readonly Maneuvers: "maneuvers";
    readonly Instructions: "instructions";
};
export type BaseTraceRequestDirectionsTypeEnum = (typeof BaseTraceRequestDirectionsTypeEnum)[keyof typeof BaseTraceRequestDirectionsTypeEnum];
/**
 * @export
 */
export declare const BaseTraceRequestShapeMatchEnum: {
    readonly EdgeWalk: "edge_walk";
    readonly MapSnap: "map_snap";
    readonly WalkOrSnap: "walk_or_snap";
};
export type BaseTraceRequestShapeMatchEnum = (typeof BaseTraceRequestShapeMatchEnum)[keyof typeof BaseTraceRequestShapeMatchEnum];
/**
 * Check if a given object implements the BaseTraceRequest interface.
 */
export declare function instanceOfBaseTraceRequest(value: object): value is BaseTraceRequest;
export declare function BaseTraceRequestFromJSON(json: any): BaseTraceRequest;
export declare function BaseTraceRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): BaseTraceRequest;
export declare function BaseTraceRequestToJSON(json: any): BaseTraceRequest;
export declare function BaseTraceRequestToJSONTyped(value?: BaseTraceRequest | null, ignoreDiscriminator?: boolean): any;
//# sourceMappingURL=BaseTraceRequest.d.ts.map