import { GeocodingSource } from './GeocodingSource';
import { GeocodingLayer } from './GeocodingLayer';
/**
 *
 * @export
 * @interface SearchStructuredQuery
 */
export interface SearchStructuredQuery {
    /**
     * A street name, optionally with a house number.
     * @type {string}
     * @memberof SearchStructuredQuery
     */
    address?: string;
    /**
     * Varies by area, but has a locally specific meaning (NOT always an official administrative unit).
     * @type {string}
     * @memberof SearchStructuredQuery
     */
    neighbourhood?: string;
    /**
     * A unit within a city (not widely used, but present in places like NYC and Mexico City).
     * @type {string}
     * @memberof SearchStructuredQuery
     */
    borough?: string;
    /**
     * The city, village, town, etc. that the place/address is part of.
     * @type {string}
     * @memberof SearchStructuredQuery
     */
    locality?: string;
    /**
     * Administrative divisions between localities and regions. Not commonly used as input to structured geocoding.
     * @type {string}
     * @memberof SearchStructuredQuery
     */
    county?: string;
    /**
     * Typically the first administrative division within a country. For example, a US state or a Canadian province.
     * @type {string}
     * @memberof SearchStructuredQuery
     */
    region?: string;
    /**
     * A mail sorting code.
     * @type {string}
     * @memberof SearchStructuredQuery
     */
    postalcode?: string;
    /**
     * A country code in ISO 3116-1 alpha-2 or alpha-3 format.
     * @type {string}
     * @memberof SearchStructuredQuery
     */
    country?: string;
    /**
     * The latitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lon`.
     * @type {number}
     * @memberof SearchStructuredQuery
     */
    focusPointLat?: number;
    /**
     * The longitude of the point to focus the search on. This will bias results toward the focus point. Requires `focus.point.lat`.
     * @type {number}
     * @memberof SearchStructuredQuery
     */
    focusPointLon?: number;
    /**
     * Defines the min latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
     * @type {number}
     * @memberof SearchStructuredQuery
     */
    boundaryRectMinLat?: number;
    /**
     * Defines the max latitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
     * @type {number}
     * @memberof SearchStructuredQuery
     */
    boundaryRectMaxLat?: number;
    /**
     * Defines the min longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
     * @type {number}
     * @memberof SearchStructuredQuery
     */
    boundaryRectMinLon?: number;
    /**
     * Defines the max longitude component of a bounding box to limit the search to. Requires all other `boundary.rect` parameters to be specified.
     * @type {number}
     * @memberof SearchStructuredQuery
     */
    boundaryRectMaxLon?: number;
    /**
     * The latitude of the center of a circle to limit the search to. Requires `boundary.circle.lon`.
     * @type {number}
     * @memberof SearchStructuredQuery
     */
    boundaryCircleLat?: number;
    /**
     * The longitude of the center of a circle to limit the search to. Requires `boundary.circle.lat`.
     * @type {number}
     * @memberof SearchStructuredQuery
     */
    boundaryCircleLon?: number;
    /**
     * The radius of the circle (in kilometers) to limit the search to. Defaults to 50km if unspecified.
     * @type {number}
     * @memberof SearchStructuredQuery
     */
    boundaryCircleRadius?: number;
    /**
     * A list of country codes in ISO 3116-1 alpha-2 or alpha-3 format.
     * @type {Array<string>}
     * @memberof SearchStructuredQuery
     */
    boundaryCountry?: Array<string>;
    /**
     * The GID of an area to limit the search to.
     * @type {string}
     * @memberof SearchStructuredQuery
     */
    boundaryGid?: string;
    /**
     * A list of layers to limit the search to.
     * @type {Array<GeocodingLayer>}
     * @memberof SearchStructuredQuery
     */
    layers?: Array<GeocodingLayer>;
    /**
     * A list of sources to limit the search to.
     * @type {Array<GeocodingSource>}
     * @memberof SearchStructuredQuery
     */
    sources?: Array<GeocodingSource>;
    /**
     * The maximum number of results to return.
     * @type {number}
     * @memberof SearchStructuredQuery
     */
    size?: number;
    /**
     * A BCP47 language tag which specifies a preference for localization of results. By default, results are in the default locale of the source data, but specifying a language will attempt to localize the results. Note that while a `langtag` (in RFC 5646 terms) can contain script, region, etc., only the `language` portion, an ISO 639 code, will be considered. So `en-US` and `en-GB` will both be treated as English.
     * @type {string}
     * @memberof SearchStructuredQuery
     */
    lang?: string;
}
/**
 * Check if a given object implements the SearchStructuredQuery interface.
 */
export declare function instanceOfSearchStructuredQuery(value: object): value is SearchStructuredQuery;
export declare function SearchStructuredQueryFromJSON(json: any): SearchStructuredQuery;
export declare function SearchStructuredQueryFromJSONTyped(json: any, ignoreDiscriminator: boolean): SearchStructuredQuery;
export declare function SearchStructuredQueryToJSON(json: any): SearchStructuredQuery;
export declare function SearchStructuredQueryToJSONTyped(value?: SearchStructuredQuery | null, ignoreDiscriminator?: boolean): any;
//# sourceMappingURL=SearchStructuredQuery.d.ts.map