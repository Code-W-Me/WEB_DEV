import { CostingOptions } from './CostingOptions';
import { Contour } from './Contour';
import { Coordinate } from './Coordinate';
import { IsochroneCostingModel } from './IsochroneCostingModel';
/**
 *
 * @export
 * @interface IsochroneRequest
 */
export interface IsochroneRequest {
    /**
     * An identifier to disambiguate requests (echoed by the server).
     * @type {string}
     * @memberof IsochroneRequest
     */
    id?: string;
    /**
     *
     * @type {Array<Coordinate>}
     * @memberof IsochroneRequest
     */
    locations: Array<Coordinate>;
    /**
     *
     * @type {IsochroneCostingModel}
     * @memberof IsochroneRequest
     */
    costing: IsochroneCostingModel;
    /**
     *
     * @type {CostingOptions}
     * @memberof IsochroneRequest
     */
    costingOptions?: CostingOptions;
    /**
     *
     * @type {Array<Contour>}
     * @memberof IsochroneRequest
     */
    contours: Array<Contour>;
    /**
     * If true, the generated GeoJSON will use polygons. The default is to use LineStrings. Polygon output makes it easier to render overlapping areas in some visualization tools (such as MapLibre renderers).
     * @type {boolean}
     * @memberof IsochroneRequest
     */
    polygons?: boolean;
    /**
     * A value in the range [0, 1] which will be used to smooth out or remove smaller contours. A value of 1 will only return the largest contour for a given time value. A value of 0.5 drops any contours that are less than half the area of the largest contour in the set of contours for that same time value.
     * @type {number}
     * @memberof IsochroneRequest
     */
    denoise?: number;
    /**
     * The value in meters to be used as a tolerance for Douglas-Peucker generalization.
     * @type {number}
     * @memberof IsochroneRequest
     */
    generalize?: number;
    /**
     * If true, then the output GeoJSON will include the input locations as two MultiPoint features: one for the exact input coordinates, and a second for the route network node location that the point was snapped to.
     * @type {boolean}
     * @memberof IsochroneRequest
     */
    showLocations?: boolean;
}
/**
 * Check if a given object implements the IsochroneRequest interface.
 */
export declare function instanceOfIsochroneRequest(value: object): value is IsochroneRequest;
export declare function IsochroneRequestFromJSON(json: any): IsochroneRequest;
export declare function IsochroneRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): IsochroneRequest;
export declare function IsochroneRequestToJSON(json: any): IsochroneRequest;
export declare function IsochroneRequestToJSONTyped(value?: IsochroneRequest | null, ignoreDiscriminator?: boolean): any;
//# sourceMappingURL=IsochroneRequest.d.ts.map